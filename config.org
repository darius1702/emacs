#+TITLE: Emacs configuration
#+AUTHOR: Darius Schefer
#+PROPERTY: header-args:emacs-lisp :tangle init.el :mkdirp yes
#+STARTUP: show2levels

* Build flags
Nativecomp, pgtk, ...

#+begin_src sh
./configure --with-native-compilation=aot --with-pgtk --without-x --without-ns --with-imagemagick --without-compress-install --disable-gc-mark-trace --enable-link-time-optimization 'CFLAGS=-O3 -march=native'
#+end_src


* Early init
** No startup message spam
The docs say you can ~(setq inhibit-startup-echo-area-message "$username")~ but that doesn't work for me.
Also lexical-bindings for early-init.

#+begin_src emacs-lisp :tangle early-init.el
;; -*- lexical-binding: t -*-
(setq-default inhibit-message t)
(add-hook 'window-setup-hook
          (lambda ()
            (setq-default inhibit-message nil)
            ;; The echo area is too small and will resize the first time a message is displayed
            ;; when messages are inhibited during startup.
            ;; I find that kind of annoying, so just message "" here so it resizes immediately.
            (message "")))

(setopt inhibit-startup-message t
        initial-scratch-message nil
        server-client-instructions nil)
#+end_src

** Faster startup
This makes emacs start a little faster, or maybe I am just imagining things.

#+begin_src emacs-lisp :tangle early-init.el
(defvar darius/file-name-handler-alist file-name-handler-alist)
(setopt file-name-handler-alist nil)

(add-hook 'emacs-startup-hook
          (lambda ()
            (setopt file-name-handler-alist darius/file-name-handler-alist)))
#+end_src

** Garbage collection
I find it really annoying when I have tiny stutters while scrolling due to GC.
This is probably a very ugly solution but it has worked for me so far:
Set ~gc-cons-threshold~ really high to make emacs not consider doing GC on its own.
When emacs is idle for 2 seconds, manually trigger a GC.
This way the GC pause doesn't happen while I am interacting with the UI.

#+begin_src emacs-lisp :tangle early-init.el
(setopt gc-cons-threshold (eval-when-compile (* 5 1024 1024 1024)))
(run-with-idle-timer 2 t (lambda () (garbage-collect)))
#+end_src

** Default clutter
Adjust some default settings,
I don't know why I have this in the early-init but I moved it here at some point.

#+begin_src emacs-lisp :tangle early-init.el
(setopt use-dialog-box nil
        use-short-answers t)

(setopt native-comp-async-report-warnings-errors nil)

(tool-bar-mode -1)
(menu-bar-mode -1)
(scroll-bar-mode -1)
(tooltip-mode -1)
(blink-cursor-mode -1)

(winner-mode 1)                         ; window layout history
(undelete-frame-mode 1)
#+end_src

* Builtin stuff
** Setup
Lexical bindings and set+load custom file

#+begin_src emacs-lisp
;; -*- lexical-binding: t -*-
(setq custom-file (concat user-emacs-directory "custom.el"))
(when (file-exists-p custom-file)
  (load custom-file))
#+end_src

** Misc
Tweaks that don't fit the other categories

#+begin_src emacs-lisp
;; ask before exiting
(setopt confirm-kill-emacs 'yes-or-no-p)

;; make all the things case insensitive
(setopt read-buffer-completion-ignore-case t
        read-file-name-completion-ignore-case t
        completion-ignore-case t)

;; make read-only buffers use `view-mode'
(setopt view-read-only t
        view-inhibit-help-message t)

(setopt shell-command-prompt-show-cwd t)

(setopt vc-follow-symlinks t)

(setopt read-process-output-max (* 1024 1024 4))

;; according to someone else's config this does something good
(setopt pgtk-wait-for-event-timeout 0.001)
#+end_src

** Default Keybindings
Unbind some defaults and bind some more keys

#+begin_src emacs-lisp
(keymap-global-unset "C-x C-c")            ; stop accidentally quitting emacs
(keymap-global-unset "C-x C-z")            ; stop accidentally suspending emacs
(keymap-global-unset "C-h g")              ; really
(keymap-global-unset "C-z")                ; stop accidentally suspending emacs (other binding)

(keymap-global-set "M-o" #'other-window)
(keymap-global-set "M-O" #'other-window-backward)
(keymap-global-set "C-M-S-o" #'window-layout-transpose)
#+end_src

*** Mouse and Trackpad
Make right click behave like left click and make the middle button only paste with a prefix.
Also I keep accidentally triggering pinch-to-zoom and ctrl+mousewheel on my laptop

#+begin_src emacs-lisp
(keymap-global-set "<mouse-3>" #'mouse-set-point)
(keymap-global-set "<down-mouse-3>" #'mouse-drag-region)
(keymap-global-set "<drag-mouse-3>" #'mouse-set-region)

(keymap-global-set "<mouse-2>"
            #'(lambda (arg) (interactive "P") (when arg (mouse-yank-primary))))

(keymap-global-unset "C-<wheel-up>")
(keymap-global-unset "C-<wheel-down>")
(keymap-global-unset "<pinch>")
#+end_src

** User interface
Change default UI settings

#+begin_src emacs-lisp
;; remove the "GNU Emacs at [hostname]" part
(setopt frame-title-format '("%b")
        frame-resize-pixelwise t)

(column-number-mode t)

(setopt scroll-preserve-screen-position t
        scroll-margin 0                 ; becuase of ultra-scroll
        scroll-conservatively 3
        next-screen-context-lines 10)

(use-package paren
  :custom
  (show-paren-delay 0.1)
  (show-paren-when-point-inside-paren t)
  (show-paren-when-point-in-periphery t)
  (show-paren-context-when-offscreen  'overlay)
  :config
  (show-paren-mode t))

(setopt tab-bar-show 1 ; only show tab bar when more than 1 tab
        tab-bar-close-button-show nil)

;; show active region in inactive windows
(setopt highlight-nonselected-windows t)

;; (relative) line numbers
(use-package display-line-numbers
  :custom
  (display-line-numbers-type 'relative)
  (display-line-numbers-width 3)
  (display-line-numbers-grow-only t)
  :hook
  (prog-mode . display-line-numbers-mode))

;; zoom text in smaller increments
(setopt text-scale-mode-step 1.05)

;; indicate lines exceeding fill-colum
(setopt display-fill-column-indicator-warning t)

(use-package whitespace
  :custom
  (whitespace-line-column nil) ; use `fill-column'
  (whitespace-style '(face trailing tabs indentatinon
                           space-before-tab space-after-tab
                           tab-mark space-mark empty)))
#+end_src

** Editing and Formatting
Changes to default editing behavior

#+begin_src emacs-lisp
;; this is `zap-to-char' by default
(keymap-global-set "M-z" #'zap-up-to-char)

;; Act on region if active, otherwise on line/word
(keymap-global-set "M-D" #'duplicate-dwim)
(keymap-global-set "M-u" #'upcase-dwim)
(keymap-global-set "M-l" #'downcase-dwim)
(keymap-global-set "M-c" #'capitalize-dwim)

;; join line with line above
(keymap-global-set "C-c j" #'join-line)

;; continue comment on new line
(keymap-set prog-mode-map "M-RET" #'comment-indent-new-line)

;; indentation+completion with TAB
(setopt tab-always-indent 'complete)

(use-package dabbrev
  :custom
  (dabbrev-case-replace nil))

;; read .editorconfig if present
(editorconfig-mode t)

(setq-default indent-tabs-mode nil
              tab-width 4)

(add-to-list 'write-file-functions #'delete-trailing-whitespace)

(setopt require-final-newline t)

(global-visual-line-mode 1)

;; make C-w delete a word backwards when no region is active
(setopt kill-region-dwim 'emacs-word)

(electric-pair-mode t)

;; save system clipboard to kill ring before overwriting it
(setopt save-interprogram-paste-before-kill t)

(setopt mouse-yank-at-point t)

(setopt sentence-end-double-space nil
        sentence-end "[.\",;!?*:'] ")
#+end_src

** Buffers
Isearch, ibuffer, imenu, ...

*** Keybinds and misc
As the heading suggests

#+begin_src emacs-lisp
(keymap-global-set "C-<tab>" #'mode-line-other-buffer)

(use-package window
  :custom
  (split-window-preferred-direction 'longest)
  (switch-to-buffer-obey-display-actions nil)
  (switch-to-buffer-in-dedicated-window 'pop))

;; automatically revert buffers that change on disk
(use-package autorevert
  :custom
  (global-auto-revert-non-file-buffers t)
  (auto-revert-avoid-polling t)
  (auto-revert-check-vc-info t)
  :config
  (auto-revert-mode 1))
#+end_src

*** Isearch
Searching within a buffer

#+begin_src emacs-lisp
(use-package isearch
  :custom
  (isearch-wrap-pause 'no-ding)
  (isearch-lazy-count t)
  (lazy-count-prefix-format "(%s/%s) ")
  (search-whitespace-regexp ".*?")
  (lazy-highlight-initial-delay 0))
#+end_src

*** Imenu
Navigate buffer via headings/definitions/...
These are settings for the builtin ~imenu~, [[*Consult][Consult]] has it's own version, ~consult-imenu~

#+begin_src emacs-lisp
(use-package imenu
  :hook
  (imenu-after-jump . recenter)
  :custom
  (imenu-auto-rescan t)
  (imenu-flatten t)
  (imenu-space-replacement "_"))
#+end_src

*** Ibuffer
Ibuffer for buffer management.
The *vc-status* format below depends on [[*Ibuffer-vc][Ibuffer-vc]].

#+begin_src emacs-lisp
(use-package ibuffer
  :bind
  (("C-x C-b" . ibuffer)
   (:map ibuffer-mode-map ("M-o" . other-window)))
  :hook
  (ibuffer-mode . (lambda ()
                    (ibuffer-switch-to-saved-filter-groups "default")
                    (ibuffer-auto-mode t)))
  :custom
  (ibuffer-expert t)                    ; don't prompt for everything
  (ibuffer-display-summary nil)
  (ibuffer-human-readable-size t)
  (ibuffer-show-empty-filter-groups nil)
  (ibuffer-saved-filter-groups
   '(("default"
      ("Code" (and
               (derived-mode . prog-mode)
               (not (name . "^\\*scratch\\*$"))))
      ("Dir" (mode . dired-mode))
      ("Org" (mode . org-mode))
      ("Pdf" (mode . pdf-view-mode))
      ("TeX" (filename . "\\.tex$"))
      ("Term" (or
               (mode . shell-mode)
               (mode . term-mode)
               (mode . eshell-mode)
               (mode . compilation-mode)
               (mode . eat-mode)))
      ("Git" (name . "^magit"))
      ("Help" (or (mode . help-mode) (mode . Man-mode) (mode . Info-mode)))
      ("Misc" (name . "^\\*.**\\*$")))))
  (ibuffer-formats
   '((mark modified read-only vc-status-mini " "
           (name 18 18 :left :elide)
           " "
           (size 9 -1 :right)
           " "
           (mode 16 16 :left :elide)
           " "
           (vc-status 16 16 :left)))))
#+end_src

** File navigation
File browsing, projects, recent files, bookmarks

*** Dired
File browsing on crack

#+begin_src emacs-lisp
(defun darius/dired-create-directory ()
  "Wrapper around `dired-create-directory' with no minibuffer completion."
  (interactive)
  (let ((dir (read-from-minibuffer "Make directory: ")))
    (dired-create-directory dir)))

(use-package dired
  :custom
  (dired-recursive-deletes 'top) ; this is the default but I'm paranoid
  (dired-dwim-target t)
  (dired-listing-switches "-alh")
  (dired-kill-when-opening-new-dired-buffer t)
  (dired-auto-revert-buffer t)
  (dired-do-revert-buffer t)
  (dired-hide-details-hide-symlink-targets nil)
  (dired-create-destination-dirs 'ask)
  :hook (dired-mode . dired-hide-details-mode)
  :bind
  ("<mouse-8>" . dired-jump) ; back button
  (:map dired-mode-map
        ("+" . darius/dired-create-directory)
        ("<mouse-2>" . dired-mouse-find-file)
        ("SPC" . dired-jump)
        ("b" . dired-jump))
  :config
  ;; Make `dired-do-shell-command' suggest better defaults for some filetypes
  (add-to-list 'dired-guess-shell-alist-user '("\\.pdf\\'" "zathura"))
  (add-to-list 'dired-guess-shell-alist-user '("\\.mp4\\'" "mpv")))
#+end_src

*** Projects
Keep track of projects and run actions on them

#+begin_src emacs-lisp
(use-package project
  :config
  (add-to-list 'project-switch-commands '(project-dired "Dired")))
#+end_src

*** Recent files
Remember recently visited files

#+begin_src emacs-lisp
(use-package recentf
  :custom
  (recentf-auto-cleanup 'never)
  (recentf-max-menu-items 0)
  (recentf-max-saved-items 100)
  :bind
  ("M-g r" . recentf-open)
  ("M-g R" . recentf-open-files)
  :config
  (recentf-mode))
#+end_src

*** Bookmarks
Bookmarks are saved in the ~bookmarks.eld~ file

#+begin_src emacs-lisp
(keymap-global-set "M-g b" #'bookmark-jump)

(setopt bookmark-fringe-mark nil ; don't show bookmarks in buffers
        bookmark-save-flag 1)    ; don't wait until emacs exits to save bookmarks
#+end_src

*** Grep
Grep

#+begin_src emacs-lisp
(use-package grep
  :custom
  (grep-use-headings t)
  :bind
  (:map grep-mode-map
        ("F" . next-error-follow-minor-mode)))
#+end_src

** Minibuffer things
Setup minibuffer and ~completing-read~

#+begin_src emacs-lisp
;; make `completing-read-multiple' prompt show the separator
(setopt crm-prompt "[%d (%s)] %p")

;; remember minibuffer history
(savehist-mode t)

(setopt enable-recursive-minibuffers t
        minibuffer-default-prompt-format " [%s]"
        read-minibuffer-restore-windows nil
        minibuffer-prompt-properties '(read-only t cursor-intangible t face minibuffer-prompt)
        minibuffer-follows-selected-frame nil)

(minibuffer-electric-default-mode t)
(minibuffer-depth-indicate-mode t)
#+end_src

** Compilation and Comint
Changes to compile and comint buffers

#+begin_src emacs-lisp
(use-package compile
  :custom
  (compilation-max-output-line-length 800)
  (compilation-scroll-output t)
  (compile-command "")
  :hook
  (compilation-filter . ansi-color-compilation-filter)
  :bind
  (("C-c c" . compile)
  ("C-c r" . recompile)
  ("M-N" . next-error)
  ("M-P" . previous-error))
  (:map compilation-mode-map ("r" . recompile)))

(use-package comint
  :custom
  (comint-input-ignoredups t)
  (comint-prompt-read-only t))
#+end_src

** Help and Docs
Help popups, linting, documentation, ...

#+begin_src emacs-lisp
(setopt suggest-key-bindings nil
        echo-keystrokes 0.01
        echo-keystrokes-help nil)

;; make apropos search more extensively
(setopt apropos-do-all t)

;; show character name in  C-x =
(setopt what-cursor-show-names t)

;; make mouse side buttons go back and forth in help and info buffers
(use-package help-mode
  :bind
  (:map help-mode-map
        ("<mouse-8>" . help-go-back)
        ("<mouse-9>" . help-go-forward)))

(use-package info
  :custom
  (Info-fontify-visited-nodes nil)
  :bind
  (:map Info-mode-map
        ("<mouse-8>" . Info-history-back)
        ("<mouse-9>" . Info-history-forward)))

;; syntax checking
(use-package flymake
  :custom
  (flymake-wrap-around nil)
  :bind
  ("M-n" . flymake-goto-next-error)
  ("M-p" . flymake-goto-prev-error))

;; jumping to definition etc.
(use-package xref
  :custom
  (xref-history-storage 'xref-window-local-history)
  (xref-search-program 'ripgrep))

;; help in the echo area
(use-package eldoc
  :custom
  (eldoc-idle-delay 0.3)
  (eldoc-echo-area-use-multiline-p nil))

;; show help for key bindings
(use-package which-key
  :custom (which-key-lighter "")
  :config (which-key-mode))

;; display the current function/heading/... in the modeline
(use-package which-func
  :custom
  (which-func-update-delay 0.1)
  :config
  ;; setting this with :custom doesn't work for some reason?
  (setopt which-func-unknown ":3"))

;; spell check
;; Arch linux provides /usr/share/dict/words in the extra/words package
(use-package ispell
  :custom
  (ispell-dictionary "en_US")
  (ispell-program-name "hunspell")
  (spell-alternate-dictionary "/usr/share/dict/words"))

;; manual pages (colorschemes can override the colors)
(use-package man
  :bind
  ("C-c m" . man)
  :custom
  (Man-notify-method 'thrifty) ; reuse existing manpage window if possible
  :config
  (set-face-attribute 'Man-overstrike nil :inherit font-lock-keyword-face :bold t)
  (set-face-attribute 'Man-underline nil :inherit font-lock-string-face :underline t))

#+end_src

** Proced
Process management

#+begin_src emacs-lisp
(use-package proced
  :commands proced
  :hook (proced-post-display . (lambda () (toggle-truncate-lines 1)))
  :custom
  (proced-auto-update-flag t)
  (proced-goal-attribute nil)
  (proced-enable-color-flag t)
  (proced-format 'custom)
  :config
  (add-to-list 'proced-format-alist
               '(custom user pid tree pcpu rss (args comm))))
#+end_src

** Ediff
Diff files

#+begin_src emacs-lisp
(use-package ediff
  :custom
  (ediff-keep-variants nil)
  (ediff-make-buffers-readonly-at-startup t)
  (ediff-show-clashes-only t)
  (ediff-split-window-function 'split-window-horizontally)
  (ediff-window-setup-function 'ediff-setup-windows-plain))
#+end_src

** Remote Editing
Remote editing with TRAMP

#+begin_src emacs-lisp
(setopt remote-file-name-inhibit-locks t
        tramp-use-scp-direct-remote-copying t
        remote-file-name-inhibit-auto-save-visited t)
#+end_src

** Terminal Tweaks
For running in ~-nw~ mode

#+begin_src emacs-lisp
;; make the mouse wheel scroll the buffer
(xterm-mouse-mode 1)

;; disable cursor blinking
(setopt visible-cursor nil)

(defun darius/disable-terminal-background ()
  "Removes theme background color in terminal windows"
  (unless (display-graphic-p (selected-frame))
    (set-face-attribute 'default nil :background "unspecified-bg")))

(add-hook 'window-setup-hook 'darius/disable-terminal-background)
#+end_src

** Eshell
Emacs shell aliases

#+begin_src sh :tangle eshell/alias
alias ff find-file $1
alias d dired $1

alias la ls -A
alias ll ls -lh
alias lla ls -lhA
alias l ls

alias gs magit-status
#+end_src

** Auto-saves and backups
Disble all annoying auto-generated files and make ~custom-set-variables~ go to their own file
Also disable auto-save messages

#+begin_src emacs-lisp
(make-directory (expand-file-name "tmp/auto-saves/" user-emacs-directory) t)
(setopt auto-save-list-file-prefix (expand-file-name "tmp/auto-saves/sessions/" user-emacs-directory)
        auto-save-file-name-transforms `((".*" ,(expand-file-name "tmp/auto-saves/" user-emacs-directory) t))
        auto-save-no-message t)
(setopt backup-directory-alist `(("." . ,(expand-file-name "tmp/backups/" user-emacs-directory))))
(setopt backup-by-copying t)

;; Enable when lockfiles become annoying
;; (setopt create-lockfiles nil)
#+end_src

* External Packages
** Setup
Load lisp files from ~[user-emacs-directory]/external~
Configure ~package.el~ and ~use-package~

#+begin_src emacs-lisp
(add-to-list 'load-path (file-name-concat user-emacs-directory "external"))

(use-package package
  :custom
  (package-native-compile t) ; this will just be ignored if native-comp isn't available
  (package-archives
   '(("elpa" . "https://elpa.gnu.org/packages/")
     ("elpa-devel" . "https://elpa.gnu.org/devel/")
     ("nongnu" . "https://elpa.nongnu.org/nongnu/")
     ("melpa" . "https://melpa.org/packages/")))
  (package-archive-priorities ; prefer stable elpa over devel
   '(("elpa" . 2)
     ("elpa-devel" . 1))))
#+end_src

** Useful random stuff
Some packages that don't require much configuration

*** Envrc
Load ~.envrc~ files from ~direnv~

#+begin_src emacs-lisp
(let ((nix-bin-path "/home/darius/.nix-profile/bin/"))
  (use-package envrc
    :ensure t
    :init
    (add-to-list 'exec-path nix-bin-path)
    (setenv "PATH" (concat nix-bin-path ":" (getenv "PATH")))
    :custom (envrc-none-lighter nil)
    :hook (after-init . envrc-global-mode)))
#+end_src

*** Ibuffer-vc
Version control integration for Ibuffer

#+begin_src emacs-lisp
(use-package ibuffer-vc
  :ensure t
  :bind
  (:map ibuffer-mode-map
        ("v" . ibuffer-vc-set-filter-groups-by-vc-root)))
#+end_src

*** Marginalia
Usful info in the minibuffer

#+begin_src emacs-lisp
(use-package marginalia
  :ensure t
  :init (marginalia-mode))
#+end_src

*** Colorful-mode
Colorize strings like #a7c080.
Making the frame background transparent via ~alpha-background~ makes the colors a little transparent as well sadly

#+begin_src emacs-lisp
(use-package colorful-mode
  :ensure t
  :custom (css-fontify-colors nil)
  :config
  (global-colorful-mode)
  (set-face-attribute 'colorful-base nil :box nil)) ; colors have a box around them by default which looks weird
#+end_src

*** hl-todo
Highlight keywords like TODO and FIXME in comments in source code

#+begin_src emacs-lisp
(use-package hl-todo
  :ensure t
  :hook (prog-mode . hl-todo-mode))
#+end_src

*** Multiple cursors
Easily place multiple cursors for edits

#+begin_src emacs-lisp
(use-package multiple-cursors
  :ensure t
  :custom ((mc/always-run-for-all t)
           (mc/cmds-to-run-once nil))
  :bind
  ("C-S-c C-S-c" . mc/edit-lines)
  ("C->" . mc/mark-next-like-this-word)
  ("C-M->" . mc/skip-to-next-like-this)
  ("C-<" . mc/mark-previous-like-this-word)
  ("C-M-<" . mc/skip-to-previous-like-this)
  ("C-c C-<" . mc/mark-all-like-this))
#+end_src

*** TLDR pages
Read tldr pages in emacs

#+begin_src emacs-lisp
(use-package tldr
  :ensure t
  :bind ("C-c t" . tldr))
#+end_src

*** Nov mode
Read epubs in emacs

#+begin_src emacs-lisp
(use-package nov
  :ensure t
  :mode ("\\.epub\\'" . nov-mode))
#+end_src

*** PDFgrep mode
Grep in pdfs

#+begin_src emacs-lisp
(use-package pdfgrep
  :ensure t
  :config (pdfgrep-mode))
#+end_src

*** ace-window
Switching and moving windows

#+begin_src emacs-lisp
(use-package ace-window
  :ensure t
  :bind ("C-M-o" . ace-swap-window)
  :custom
  (aw-scope 'frame))
#+end_src

*** Embark
Very cool
Still not 100% sure I get what it does

#+begin_src emacs-lisp
(use-package embark
  :ensure t
  :custom (embark-mixed-indicator-delay nil)
  :bind ("C-." . embark-act))

(use-package embark-consult
  :ensure t)
#+end_src

*** CSV-mode
Prettier csv files

#+begin_src emacs-lisp
(use-package csv-mode
  :ensure t
  :hook (csv-mode . csv-align-mode))
#+end_src

*** TMR
Set timers

#+begin_src emacs-lisp
(use-package tmr
  :ensure t
  :custom
  (tmr-sound-file nil))
#+end_src

*** Expand region
Expand the region

#+begin_src emacs-lisp
(use-package expand-region
  :ensure t
  :bind ("M-j" . er/expand-region))
#+end_src

*** EAT
Emulate a terminal

#+begin_src emacs-lisp
(use-package eat
  :ensure t
  :custom
  (eat-kill-buffer-on-exit t)
  :config
  (add-to-list 'display-buffer-alist
               '("\\(?:\\*-eat\\*\\|.*eat.*\\)"
                 (display-buffer-reuse-mode-window)))
  :bind
  (:map eat-semi-char-mode-map
        ("M-o" . other-window)))
#+end_src

*** Ultra-scroll
Doesn't have this one annoying bug that pixel-scroll-precision-mode has that
makes the page jump backwards when scrolling with the caret all the way at the
top of the screen.

For some reason this gives a 'You are not currently on a branch' git error when trying to upgrade,
no idea why.

#+begin_src emacs-lisp
;; builtin-version
;; (pixel-scroll-precision-mode 1)
;; (setopt pixel-scroll-precision-interpolate-mice nil)

(use-package ultra-scroll
  :ensure t
  :config (ultra-scroll-mode 1))
#+end_src

*** Dumb Jump
Jump to definition

#+begin_src emacs-lisp
(use-package dumb-jump
  :ensure t
  :config
  (add-hook 'xref-backend-functions #'dumb-jump-xref-activate))
#+end_src

*** Eldoc-Box
Eldoc in a popup frame

#+begin_src emacs-lisp
(use-package eldoc-box
  :ensure t
  ;; override `view-hello-file'
  :bind ("C-h h" . #'eldoc-box-help-at-point))
#+end_src

** Fontaine
Font presets

#+begin_src emacs-lisp
(use-package fontaine
  :ensure t
  :custom
  (fontaine-presets
   '((sf-mono
      :default-family "SFMono Nerd Font Mono"
      :fixed-pitch-family "SFMono Nerd Font Mono"
      :variable-pitch-family "SF Pro"
      :default-weight regular
      :default-height 110
      :fixed-pitch-weight nil ; falls back to :default-weight
      :bold-family nil
      :italic-family nil)
     (sf-mono-large
      :inherit sf-mono
      :default-height 165)
     (sf-mono-larger
      :inherit sf-mono
      :default-height 185)))
  :config
  (defun darius/reapply-fontaine ()
    (fontaine-set-preset (or (fontaine-restore-latest-preset) 'present)))
  (darius/reapply-fontaine)
  (fontaine-mode 1)
  (define-key global-map (kbd "C-c f") #'fontaine-set-preset)
  (add-hook 'server-mode-hook 'darius/reapply-fontaine))
#+end_src

** Git
Some git tools

*** Magit
Very nice git interface

#+begin_src emacs-lisp
(use-package magit
  :ensure t
  :defer t
  :bind ("C-x g" . magit-status))
#+end_src

*** Diff-hl
Show uncommitted changes in the fringe

#+begin_src emacs-lisp
(use-package diff-hl
  :ensure t
  :hook
  (magit-post-refresh . diff-hl-magit-post-refresh)
  :hook
  (prog-mode . diff-hl-mode)
  :bind
  ("C-c v n" . diff-hl-next-hunk)
  ("C-c v p" . diff-hl-previous-hunk)
  ("C-c v s" . diff-hl-show-hunk))
#+end_src

** Consult
Some nice additional completing-read stuff

#+begin_src emacs-lisp
;; builtin alternative for consult-xref
;;(setopt xref-show-definitions-function #'xref-show-definitions-completing-read)

(use-package consult
  :ensure t
  :custom
  (xref-show-definitions-function #'consult-xref)
  (xref-show-xrefs-function #'consult-xref)
  :config
  (defun darius/consult-ripgrep-hidden ()
    "Call rg with additional --hidden flag"
    (interactive)
    (let* ((consult-ripgrep-args (s-concat consult-ripgrep-args " --hidden")))
      (call-interactively 'consult-ripgrep)))
  (defun darius/consult-fd-hidden ()
    "Call fd with additional --hidden flag"
    (interactive)
    (let* ((consult-fd-args (s-concat consult-fd-args " --hidden")))
      (call-interactively 'consult-fd)))
  (with-eval-after-load 'em-prompt
    (keymap-set eshell-prompt-mode-map "M-r" #'consult-history))
  :bind
  (("C-S-Y"     . consult-yank-from-kill-ring)
   ;; M-s `search-map'
   ("M-s d"     . consult-fd)
   ("M-s D"     . darius/consult-fd-hidden)
   ("M-s l"     . consult-line)
   ("M-s L"     . consult-line-multi)
   ("M-s r"     . consult-ripgrep)
   ("M-s R"     . darius/consult-ripgrep-hidden)
   ("M-s u"     . consult-focus-lines)
   ("M-s k"     . consult-keep-lines)
   ;; M-g `goto-map'
   ("M-g g"     . consult-goto-line)
   ("M-g M-g"   . consult-goto-line)
   ("M-g e"     . consult-compile-error)
   ("M-g f"     . consult-flymake)
   ("M-g o"     . consult-outline)
   ("M-g m"     . consult-mark)
   ("M-g k"     . consult-global-mark)
   ("M-g i"     . consult-imenu)
   ("M-g I"     . consult-imenu-multi)
   :map minibuffer-local-map ("M-r" . consult-history)))

;; use consult to search for TODO, NOTE, etc
(use-package consult-todo
  :ensure t
  :after consult
  :bind ("M-s t" . consult-todo-project))
#+end_src

** PDF Tools
Some improvements over DocView

#+begin_src emacs-lisp
(use-package pdf-tools
  :ensure t
  :init
  (pdf-loader-install t) ; don't whether ask to build epdinfo
  :custom
  (pdf-view-continuous nil) ;; don't auto-switch to the next/previous page when scrolling
  (pdf-annot-default-annotation-properties '((t (label . "Darius Schefer")) (text (icon . "Comment"))))
  (pdf-view-use-scaling t)
  (pdf-view-resize-factor 1.1)
  :config
  (setq-default pdf-view-display-size 'fit-page)
  (add-to-list 'revert-without-query ".pdf")
  ;; this allows for example the synctex integration from pdf-tools to reuse a buffer
  (add-to-list 'display-buffer-alist
               '(".*\\.pdf$"
                 (display-buffer-reuse-window)
                 (reusable-frames . t)
                 (inhibit-switch-frame . t)))
  :hook
  (pdf-view-mode . (lambda () (display-line-numbers-mode -1)))
  (pdf-outline-buffer-mode . pdf-outline-follow-mode)
  :bind (:map pdf-view-mode-map
              ("C" . pdf-view-center-in-window)
              ("C-=" . pdf-view-enlarge)
              ("C--" . pdf-view-shrink)
              ;; this also makes scroll-other-window work for PDFView buffers
              ([remap scroll-up-command] . pdf-view-scroll-up-or-next-page)
              ([remap scroll-down-command] . pdf-view-scroll-down-or-previous-page)
              ("<up>" . pdf-view-previous-line-or-previous-page)
              ("<down>" . pdf-view-next-line-or-next-page)
              ("<mouse-8>" . pdf-view-scroll-down-or-previous-page)
              ("<mouse-9>" . pdf-view-scroll-up-or-next-page)
              ("t" . pdf-view-themed-minor-mode)
              ("M-g g" . pdf-view-goto-page)))
#+end_src

** Org
Settings for org-mode and related packages

*** org-mode
#+begin_src emacs-lisp
(use-package org
  :ensure t
  :mode ("\\.org\\'" . org-mode)
  :hook (org-mode . turn-on-org-cdlatex)
  :diminish org-cdlatex-mode
  :custom
  (org-directory "~/Notes")
  (org-default-notes-file (concat org-directory "/index.org"))
  (org-capture-templates
   '(("t" "Todo" entry (file+headline "~/Notes/index.org" "Stuff")
      "* %?\n  %i\n")
     ("T" "Todo [with context]" entry (file+headline "~/Notes/index.org" "Stuff")
      "* %?\n  %i\n  %a\n")
     ("k" "KITcar" entry (file+headline "~/Notes/kitcar.org" "Stuff")
      "* %?\n  %i \n%U\n")
     ("K" "KITcar [with context]" entry (file+headline "~/Notes/kitcar.org" "Stuff")
      "* %?\n  %i \n%U\n %a\n")))
  (org-refile-targets
   '((nil :maxlevel . 3)
     (org-agenda-files :maxlevel . 3)))
  (org-agenda-span 'month)
  (org-agenda-files '("~/Notes"))
  (org-todo-keywords '((sequence "TODO(t)" "IN-PROGRESS(p)" "WAITING(w)" "|" "DONE(d)")))
  (org-use-fast-todo-selection 'expert)
  (org-return-follows-link t)
  (calendar-date-style 'european)
  (calendar-week-start-day 1)
  (org-imenu-depth 7)
  (org-highlight-latex-and-related '(latex))
  (org-hide-emphasis-markers t)    ; org-appear my beloved (see below)
  (org-M-RET-may-split-line '((default . nil)))
  (org-bookmark-names-plist nil) ; stop org-capture from creating bookmarks
  (org-src-window-setup 'plain)
  (org-src-preserve-indentation nil)
  (org-edit-src-content-indentation 0)
  (org-ellipsis "...") ; setting this explicitly makes it show in a different face
  :config
  ;; follow links to files in the same window
  (setcdr (assoc 'file org-link-frame-setup) 'find-file)
  ;; remove some decoration from links
  (set-face-attribute 'org-cite-key nil :underline nil)
  (set-face-attribute 'org-cite nil :underline nil)
  :bind
  ("C-c o a" . org-agenda)
  ("C-c o A" . consult-org-agenda)
  ("C-c o t" . org-todo-list)
  ("C-c o c" . org-capture)
  (:map org-mode-map
        ("C-c o s" . org-store-link)
        ("C-c o h" . consult-org-heading)))

;; builtin package to make org documents more readable
(use-package org-indent
  :hook org-mode
  :diminish)
#+end_src

*** org-appear
Show emphasis markers like ** and some other things when point is inside them

#+begin_src emacs-lisp
(use-package org-appear
  :ensure t
  :custom
  (org-appear-autoemphasis t)
  (org-appear-autoentities t)
  (org-appear-autosubmarkers t)
  (org-appear-inside-latex t)
  :hook (org-mode . org-appear-mode))
#+end_src

*** org-modern
Nicer visuals
#+begin_src emacs-lisp
(use-package org-modern
  :ensure t
  :after org
  :custom
  (org-modern-star 'fold)
  (org-modern-fold-stars '(("îª¼" . "î©±")))
  (org-modern-block-fringe nil) ;; doesn't work with org-indent-mode
  (org-modern-checkbox
   '((88 . "ó°„²")   ; done
     (45 . "ó°¡–")   ; in-progress
     (32 . "î™€"))) ; todo
  :hook (org-mode . org-modern-mode))
#+end_src

*** org-present
Simple presentations from org-mode buffers

#+begin_src emacs-lisp
(use-package visual-fill-column
  :ensure t
  :custom
  (visual-fill-column-center-text t)
  (visual-fill-column-width 110))

(use-package org-present
  :ensure t
  :after visual-fill-column
  :config
  (defun darius/org-present-start ()
    (visual-fill-column-mode 1)
    (read-only-mode 1))
  (defun darius/org-present-end ()
    (visual-fill-column-mode 0)
    (read-only-mode 0))
  ;; this doesn't work with :hook for some reason
  :hook ((org-present-mode . darius/org-present-start)
         (org-present-mode-quit . darius/org-present-end)))
#+end_src

** Spell checking
Ispell is slow

#+begin_src emacs-lisp
(use-package jinx
  :ensure t
  :bind
  ("M-$" . jinx-correct)
  ("C-M-$" . jinx-languages))
#+end_src

** Completion at point
Completion invoked by ~complete-symbol~ etc

*** Corfu
Completion

#+begin_src emacs-lisp
(use-package corfu
  :ensure t
  :custom
  (corfu-auto-delay 0.1)
  (corfu-cycle t)
  (corfu-auto t)
  (corfu-auto-prefix 3)
  (corfu-separator ?\s)
  (corfu-preview-current 'insert)
  (corfu-on-exact-match nil)
  (corfu-popupinfo-mode t)
  (corfu-popupinfo-delay '(nil . 0.0))
  (global-corfu-minibuffers t)

  :config
  (defun corfu-move-to-minibuffer ()
    (interactive)
    (pcase completion-in-region--data
      (`(,beg ,end ,table ,pred ,extras)
       (let ((completion-extra-properties extras)
             completion-cycle-threshold completion-cycling)
         (consult-completion-in-region beg end table pred)))))
  (add-to-list 'corfu-continue-commands #'corfu-move-to-minibuffer)
  :bind ; Stop stealing my keybinds you weirdo
  (:map corfu-map
        ("RET" . nil)
        ([remap move-beginning-of-line] . nil)
        ([remap move-end-of-line] . nil)
        ([remap next-line] . nil)
        ([remap previous-line] . nil)
        ("M-m" . 'corfu-move-to-minibuffer))
  :init (global-corfu-mode))
#+end_src

*** Corfu nerd icons
Pretty icons, still not sure if I like this

#+begin_src emacs-lisp
(use-package nerd-icons-corfu
  :ensure t
  :after corfu
  :config
  (add-to-list 'corfu-margin-formatters #'nerd-icons-corfu-formatter))
#+end_src

*** CAPE
Completion At Point Extensions
Makes corfu also complete filenames and consider dabbrev

#+begin_src emacs-lisp
(use-package cape
  :ensure t
  :init
  (add-hook 'completion-at-point-functions #'cape-dabbrev)
  (add-hook 'completion-at-point-functions #'cape-file)
  (add-hook 'completion-at-point-functions #'cape-elisp-block))
#+end_src

** Minibuffer completion
Set up vertico, orderless and tweak some emacs completion defaults

#+begin_src emacs-lisp
(use-package vertico
  :ensure t
  :init (vertico-mode))

(use-package vertico-directory
  :after vertico
  :bind (:map vertico-map
              ("DEL" . vertico-directory-delete-char)
              ("C-DEL" . vertico-directory-up)
              ("M-DEL" . vertico-directory-delete-word))
  :hook (rfn-eshadow-update-overlay . vertico-directory-tidy))

(use-package orderless
  :ensure t
  :init
  (setopt completion-styles '(substring orderless basic)
	      completion-category-defaults nil
	      completion-category-overrides '((file (styles partial-completion)))))
#+end_src

** Colorscheme
The most important thing tbh.

#+begin_src emacs-lisp
;; (add-to-list 'default-frame-alist '(alpha-background . 98)) ; a little transparency

(use-package catppuccin-theme
  :ensure t
  :config
  (add-hook 'org-mode-hook  #'darius/catppuccin-org-setup))

(defun darius/catppuccin-load-light ()
  (mapc #'disable-theme custom-enabled-themes)
  (catppuccin-load-flavor 'latte)
  (darius/catppuccin-face-setup))

(defun darius/catppuccin-load-dark ()
  (mapc #'disable-theme custom-enabled-themes)
  (catppuccin-load-flavor 'mocha)
  ;; reset to default colors
  (catppuccin-set-color 'base     "#1e1e2e" 'mocha)
  (catppuccin-set-color 'mantle   "#181825" 'mocha)
  (catppuccin-set-color 'crust    "#11111b" 'mocha)
  (catppuccin-set-color 'surface0 "#313244" 'mocha)
  (catppuccin-set-color 'surface1 "#45475a" 'mocha)
  (catppuccin-set-color 'surface2 "#585b70" 'mocha)
  (catppuccin-reload)
  (darius/catppuccin-face-setup))

(defun darius/catppuccin-load-darker ()
  (mapc #'disable-theme custom-enabled-themes)
  (catppuccin-load-flavor 'mocha)
  (catppuccin-set-color 'base     "#1c1c1c" 'mocha)
  (catppuccin-set-color 'mantle   "#161616" 'mocha)
  (catppuccin-set-color 'crust    "#070707" 'mocha)
  (catppuccin-set-color 'surface0 "#282828" 'mocha)
  (catppuccin-set-color 'surface1 "#404040" 'mocha)
  (catppuccin-set-color 'surface2 "#525252" 'mocha)
  (catppuccin-reload)
  (darius/catppuccin-face-setup))

;; TODO on first init, `font-latex' is not found
;; because this is loaded before auctex
;; but I also don't want to move this further down/auctex up
;; maybe the `with-eval-after-load' fixes it? I'm too lazy to test
(defun darius/catppuccin-face-setup ()
  "Common tweaks for all catppuccin themes"
  (set-face-attribute 'line-number nil :foreground (catppuccin-color 'overlay0))
  (set-face-attribute 'link nil :underline nil :foreground (catppuccin-color 'blue))
  (set-face-attribute 'mode-line-highlight nil :box nil :foreground (catppuccin-color 'blue))
  (set-face-attribute 'minibuffer-nonselected nil :foreground (catppuccin-color 'red) :background 'unspecified)
  (with-eval-after-load 'font-latex
    (set-face-attribute 'font-latex-sectioning-5-face nil :foreground (catppuccin-color 'red))))

(defun darius/catppuccin-org-setup ()
  "Set up org-mode specific faces"
  (set-face-attribute 'org-block nil :foreground (catppuccin-color 'text)))

(darius/catppuccin-load-darker)         ; initial theme

(defun darius/pick-theme ()
  (interactive)
  (let* ((themes '(("catppuccin-light"  . darius/catppuccin-load-light)
                   ("catppuccin-dark"   . darius/catppuccin-load-dark)
                   ("catppuccin-darker" . darius/catppuccin-load-darker)))
         (choice (completing-read "Load theme: " (mapcar #'car themes)))
         (fn (cdr (assoc choice themes))))
    (when fn
      (funcall fn))))
(keymap-global-set "<f12>" #'darius/pick-theme)
#+end_src

** Diminish
Get rid of some clutter in the modeline
Doesn't work properly if it's not all the way at the end for some reason
This diminished some built-in modes, for external packages and org the :diminish
is in the use-package declaration

#+begin_src emacs-lisp
(use-package diminish
  :ensure t
  :diminish 'visual-line-mode
  :diminish 'eldoc-mode
  :diminish 'auto-revert-mode)
#+end_src

* Languages
Programming language specific stuff

** Treesitter
Automatically install tree-sitter grammars and enable the major modes

#+begin_src emacs-lisp
(use-package treesit
  :custom
  (treesit-enabled-modes t)             ; turn on all tree-sitter modes
  (treesit-auto-install-grammar 'ask)
  (treesit-font-lock-level 4))
#+end_src

** Eglot Setup
Language server stuff

#+begin_src emacs-lisp
(use-package eglot
  :custom
  (eglot-ignored-server-capabilities '(:documentHighlightProvider))
  (eglot-autoshutdown t)
  (eglot-extend-to-xref t)
  (eglot-events-buffer-size 0)          ; deprecated?
  (eglot-events-buffer-config '(:size 0 :format short))
  (jsonrpc-event-hook nil)
  :bind
  (:map eglot-mode-map ; see :config for prefix maps
        ;; C-c e a -> code-actions
        ;; C-c e g -> find
        ;; C-c e s -> show
        ("C-c e TAB" . eglot-format)
        ("C-c e i" . eglot-inlay-hints-mode)
        ("C-c e l" . eglot-list-connections)
        ("C-c e r" . eglot-rename))
  :config
  ;; couldn't get this nested keymap to work with use-package :c
  (defvar-keymap darius/eglot-code-actions-map
    :doc "Bindings for eglot code actions"
    "a" #'eglot-code-actions
    "e" #'eglot-code-action-extract
    "i" #'eglot-code-action-inline
    "o" #'eglot-code-action-organize-imports
    "q" #'eglot-code-action-quickfix
    "r" #'eglot-code-action-rewrite)
  (keymap-set eglot-mode-map "C-c e a" darius/eglot-code-actions-map)

  (defvar-keymap darius/eglot-find-map
    :doc "Bindings to find definition/declaration/type/... via eglot"
    "d" #'eglot-find-declaration
    "i" #'eglot-find-implementation
    "t" #'eglot-find-typeDefinition)
  (keymap-set eglot-mode-map "C-c e f" darius/eglot-find-map)

  (defvar-keymap darius/eglot-show-map
    :doc "Bindings to show call/type hierarchy via eglot"
    "c" #'eglot-show-call-hierarchy
    "t" #'eglot-show-type-hierarchy)
  (keymap-set eglot-mode-map "C-c e s" darius/eglot-show-map)

  ;; which-key hints for the new maps
  (which-key-add-keymap-based-replacements eglot-mode-map
    "C-c e a" `("code-actions" . ,darius/eglot-code-actions-map)
    "C-c e f" `("goto" . ,darius/eglot-find-map)
    "C-c e s" `("show" . ,darius/eglot-show-map))

  (fset #'jsonrpc--log-event #'ignore)
  (add-to-list 'eglot-server-programs
               `((scala-mode scala-ts-mode)
                 . ,(alist-get 'scala-mode eglot-server-programs)))
  ;; (add-to-list 'eglot-server-programs
  ;;              '((c-mode c++-mode c-ts-mode c++-ts-mode)
  ;;                . ("clangd"
  ;;                   "-j=16"
  ;;                   "--log=error"
  ;;                   "--malloc-trim"
  ;;                   "--background-index"
  ;;                   "--clang-tidy"
  ;;                   "--cross-file-rename"
  ;;                   "--completion-style=detailed"
  ;;                   "--pch-storage=memory"
  ;;                   "--header-insertion=never"
  ;;                   "--header-insertion-decorators=0"))) ; I hope this does what I want it to
  :hook (LaTeX-mode . eglot-ensure))
#+end_src

** Hyprlang
Hyprland ecosystem config language
Uses the builtin treesit
Get the [[https://github.com/tree-sitter-grammars/tree-sitter-hyprlang][language grammar here]]

#+begin_src emacs-lisp
(use-package hyprlang-ts-mode
  :ensure t
  :custom (hyprlang-ts-mode-indent-offset 4))
#+end_src

** C and C++
C++ and C

#+begin_src emacs-lisp
(use-package c-ts-mode
  :custom (c-ts-mode-enable-doxygen t))
#+end_src

** Rust
Funny orange crab

#+begin_src emacs-lisp
(use-package rust-ts-mode
  :custom
  (rust-ts-mode-fontify-number-suffix-as-type t))
#+end_src

** Haskell
The one and only

#+begin_src emacs-lisp
(use-package haskell-mode
  :ensure t
  :custom
  (haskell-process-auto-import-loaded-modules t)
  :init
  (setopt flymake-allowed-file-name-masks '())
  :bind
  (:map haskell-mode-map
        ("M-n" . 'haskell-goto-next-error)
        ("M-p" . 'haskell-goto-prev-error)))

(use-package haskell-interactive-mode
  :after haskell-mode
  :config
  ;; TODO this requires inf-haskell to be loaded for `haskell-prompt-regexp'
  ;; which is required neither by haskell mode nor by haskell interaction mode
  ;; there probably is a better way to do this
  (require 'inf-haskell)
  (defun darius/haskell-interactive-beginning-of-line ()
    "Skip the interactive haskell prompt at the beginning of the line"
    (interactive)
    (let* ((line (thing-at-point 'line t))
           (pos (string-match haskell-prompt-regexp line))
           (end (if pos (match-end 0) 0)))
      (beginning-of-line)
      (forward-char end)))
  :bind (:map haskell-interactive-mode-map
              ("C-a" . darius/haskell-interactive-beginning-of-line)))

(use-package hindent
  :ensure t
  :after haskell-mode
  :hook (haskell-mode . hindent-mode)
  :diminish)
#+end_src

** Scala
why
This assumes metals is installed in ~./local/bin/metals-emacs~.

#+begin_src emacs-lisp
(let ((coursier-bin-path "/home/darius/.local/share/coursier/bin/"))
  (use-package scala-mode
    :ensure t
    :interpreter ("scala" . scala-mode)
    :init
    (add-to-list 'exec-path coursier-bin-path)
    (setenv "PATH" (concat coursier-bin-path ":" (getenv "PATH")))
    :bind (:map scala-mode-map
                ("C-c c" . scala-compile)
                ("C-c r" . scala-compile))))

(use-package scala-ts-mode
  :ensure t)
#+end_src

** OCaml
Neocaml downloads a treesitter grammar for .ml and .mli files automatically.
Aims to be a bit simpler than tuareg mode and highlighting looks better.

#+begin_src emacs-lisp
(use-package neocaml
  :ensure t
  :vc (:url "https://github.com/bbatsov/neocaml" :branch "main")
  :config
  (add-hook 'neocaml-mode-hook #'neocaml-repl-minor-mode))
#+end_src

** Zig
ðŸ¦Ž

#+begin_src emacs-lisp
(use-package zig-mode
  :ensure t)
#+end_src

** Z3
SMT solving aaaa
For some reason this depends on flycheck which is very cringe

#+begin_src emacs-lisp
(add-to-list 'load-path (file-name-concat user-emacs-directory "/external/z3-mode"))

(require 'z3-mode)
#+end_src

** Proof General
Coqqq

#+begin_src emacs-lisp
(use-package proof-general
  :ensure t
  :hook (coq-mode . prettify-symbols-mode))
#+end_src

** COMMENT Agda
Load this after the ghc path is set

#+begin_src emacs-lisp
(load-file (let ((coding-system-for-read 'utf-8))
             (shell-command-to-string "agda-mode locate")))
#+end_src

** COMMENT Clojure
I guess?

#+begin_src emacs-lisp
(use-package cider
  :ensure t
  :hook (clojure-mode . cider-mode))
#+end_src

** Python
Support for virtual environments

#+begin_src emacs-lisp
(use-package pyvenv
  :ensure t)
#+end_src

** Markdown
Syntax highlighting and other stuff for markdown documents.
GFM mode seems to work better than markdown-ts-mode for me.

#+begin_src emacs-lisp
(use-package markdown-mode
  :ensure t
  :custom (markdown-fontify-code-blocks-natively t)
  :mode
  ("README\\.md\\'" . gfm-mode)
  ("\\.md\\'" . gfm-mode))
#+end_src

** Nix
â„

#+begin_src emacs-lisp
(use-package nix-ts-mode
  :ensure t
  :mode ("\\.nix\\'" . nix-ts-mode))
#+end_src

** LaTeX and Citar
Work with citations
Also requires auctex

~citar-open-entry-in-zotero~ relies on the BetterBibTex plugin for Zotero

#+begin_src emacs-lisp
(defun darius/LaTeX-mode-setup ()
  (progn
    (add-to-list 'TeX-view-program-selection '(output-pdf "PDF Tools"))
    (add-to-list 'reftex-ref-style-default-list "Hyperref")
    (TeX-source-correlate-mode t)
    (define-key LaTeX-mode-map (kbd "C-c C-r") 'reftex-reference)
    (define-key LaTeX-mode-map (kbd "C-M-i") 'complete-symbol)
    (font-latex-add-keywords '(("autoref" "*{") ("Autoref" "{")) 'reference)))

(use-package tex
  :ensure auctex
  :config
  (setopt TeX-parse-self t)
  (setopt TeX-auto-save t)
  (setopt LaTeX-electric-left-right-brace t)
  (setopt reftex-plug-into-AUCTeX t)
  (setopt reftex-default-bibliography '("~/Documents/library.bib"))
  (setq-default TeX-master 'shared)
  (setq-default TeX-command-extra-options "--shell-escape")
  :hook
  (LaTeX-mode . hl-line-mode)
  (LaTeX-mode . darius/LaTeX-mode-setup)
  (LaTeX-mode . turn-on-reftex))

;; don't ask why this needs an extra hook, I don't know either
(add-hook 'LaTeX-mode-hook (lambda () (setq TeX-command-default "LaTeXmk")))
(add-hook 'TeX-after-compilation-finished-functions #'TeX-revert-document-buffer)

(use-package citar
  :ensure t
  :config
  (defun darius/open-in-zotero (citekey)
    "Open a reference item in Zotero."
    (interactive (list (citar-select-ref)))
    (citar-open-entry-in-zotero citekey))
  :custom
  (citar-file-open-functions '(("html" . citar-file-open-external) ("pdf" . citar-file-open-external) (t . find-file)))
  (org-cite-insert-processor 'citar)
  (org-cite-follow-processor 'citar)
  (org-cite-activate-processor 'citar)
  (citar-bibliography "~/Documents/library.bib")
  :hook
  (LaTeX-mode . citar-capf-setup)
  (org-mode . citar-capf-setup)
  :bind
  ("C-c z" . 'citar-insert-citation)
  (:map org-mode-map :package org ("C-c b" . #'org-cite-insert)))

(use-package citar-embark
  :ensure t
  :after citar embark
  :diminish
  :custom (citar-at-point-function 'embark-act)
  :config
  (citar-embark-mode)
  (define-key citar-embark-map (kbd "z") #'citar-open-entry-in-zotero)
  (define-key citar-citation-map (kbd "z") #'citar-open-entry-in-zotero))

(use-package cdlatex
  :ensure t
  :custom (cdlatex-takeover-parenthesis nil)
  :hook (LaTeX-mode . turn-on-cdlatex))
#+end_src

** Typst
The cooler LaTeX?

#+begin_src emacs-lisp
(use-package typst-ts-mode
  :ensure t
  :after eglot
  :config
  ;; typst-ts-mode downloads the latest stable build of tinymist (https://myriad-dreamin.github.io/tinymist/frontend/emacs.html)
  ;; so use that if it's available
  (add-to-list 'eglot-server-programs
               `((typst-ts-mode) .
                 ,(eglot-alternatives
                   `(,typst-ts-lsp-download-path
                     "tinymist")))))
#+end_src

** SAIL
Sail architecture definition language
See [[https://github.com/rems-project/sail][GitHub]]
Requires ~sail-mode.el~ somewhere in the load-path

#+begin_src emacs-lisp
(require 'sail-mode)
(add-hook 'sail-mode-hook #'font-lock-update) ; Syntax doesn't update on its own for some reason
(add-hook 'sail-project-mode-hook #'font-lock-update)
(add-hook 'sail-mode-hook #'display-line-numbers-mode)
(add-hook 'sail-mode-hook #'(lambda () (setq-local tab-width 2)))
#+end_src

** COMMENT Lean
I love lean.
The default lean4 mode depends on lsp-mode, so until they do eglot or none at all, pull in this fork.

#+begin_src emacs-lisp
(use-package nael
  :ensure t
  :vc (:url "https://codeberg.org/mekeor/nael" :branch "release")
  :config
  (defun my-nael-setup ()
    (interactive)
    ;; Enable Emacs' built-in `TeX' input-method.  Alternatively, you
    ;; could install the external `unicode-math-input' package and
    ;; use the `unicode-math' input-method.
    (set-input-method "TeX")
    ;; Enable Emacs' built-in LSP-client Eglot.
    (eglot-ensure))

  (add-hook 'nael-mode-hook #'my-nael-setup)

  ;; Nael buffer-locally sets `compile-command' to "lake build".
  (keymap-set nael-mode-map "C-c C-c" #'project-compile)

  ;; Find out how to type the character at point in the current
  ;; input-method.
  (keymap-set nael-mode-map "C-c C-k" #'quail-show-key))
#+end_src

** Web stuff
Web stuff

#+begin_src emacs-lisp
(use-package web-mode
  :ensure t
  :custom
  (web-mode-auto-close-style 2) ;; auto-close tags on '>'
  (web-mode-markup-indent-offset 2)
  (web-mode-css-indent-offset 2)
  (web-mode-code-indent-offset 2)
  (web-mode-enable-auto-expanding t)
  (web-mode-enable-comment-annotation t)
  :mode (("\\.html\\'" . web-mode)
         ("\\.css\\'" . web-mode)))

(use-package jtsx
  :ensure t
  :mode (("\\.jsx?\\'" . jtsx-jsx-mode)
         ("\\.tsx\\'" . jtsx-tsx-mode)
         ("\\.ts\\'" . jtsx-typescript-mode))
  :hook ((jtsx-tsx-mode jtsx-jsx-mode) . eglot-ensure))

(use-package biomejs-format
  :ensure t
  :hook ((jtsx-tsx-mode jtsx-jsx-mode) . biomejs-format-mode))

(use-package json-ts-mode
  :mode ("\\.jsonc\\'" . json-ts-mode))
#+end_src

* Custom Functions
Various cringe
** Mode line
Custom mode line config.
This has to load after [[*Colorscheme][Colorscheme]] for ~catppuccin-color~

#+begin_src emacs-lisp
(defface my/mode-line-buffer-modified
  `((t
     :foreground ,(catppuccin-color 'yellow)
     :inherit bold))
  "Face for the name of a modified buffer in the mode line")

(defface my/mode-line-buffer-unmodified
  `((t
     :foreground ,(catppuccin-color 'green)
     :inherit bold))
  "Face for the name of an unmodified buffer in the mode line")

(defface my/mode-line-bold
  `((t
     :inherit bold))
  "Face for bold text in the mode line")

(defvar-local my/mode-line-buffer-name
  '(:eval
    (if (mode-line-window-selected-p)
        (if (not (buffer-modified-p))
            (if (project-current)
                (propertize (buffer-name) 'face 'my/mode-line-bold)
              (propertize (buffer-name) 'face 'my/mode-line-buffer-unmodified))
          (propertize (buffer-name) 'face 'my/mode-line-buffer-modified))
      (buffer-name))))

(defvar-local my/mode-line-project-name
  '(:eval
    (if (and (project-current)
             (not (string-equal (buffer-name) (project-name (project-current)))))
        (if (mode-line-window-selected-p)
            (if (buffer-modified-p)
                (propertize (project-name (project-current)) 'face 'my/mode-line-buffer-modified)
              (propertize (project-name (project-current)) 'face 'my/mode-line-buffer-unmodified))
          (project-name (project-current)))
      "")))

(defvar-local my/mode-line-project-separator
  '(:eval
    (if (and (project-current)
             (not (string-equal (buffer-name) (project-name (project-current)))))
        (if (mode-line-window-selected-p)
            (if (buffer-modified-p)
                (propertize "|" 'face 'my/mode-line-buffer-modified)
              (propertize "|" 'face 'my/mode-line-bold))
          "|")
      "")))

(defvar-local my/mode-line-read-only-indicator
  '(:eval
    (propertize
     (if buffer-read-only
         "%%"
       "")
     'face 'my/mode-line-bold)))

(dolist (var '(my/mode-line-buffer-name
               my/mode-line-read-only-indicator
               my/mode-line-project-name
               my/mode-line-project-separator))
  (put var 'risky-local-variable t))

(setq-default mode-line-format
              '("%e "
                mode-line-window-dedicated
                my/mode-line-read-only-indicator
                " "
                my/mode-line-project-name
                my/mode-line-project-separator
                my/mode-line-buffer-name
                "   "
                mode-line-position
                mode-line-format-right-align
                (vc-mode vc-mode)
                "   "
                mode-line-modes
                mode-line-misc-info
                mode-line-end-spaces))
#+end_src
** Zoxide
Querying the zoxide database for all entries returns them in a sorted order, so we can just pass it to completing read.
The ~table~ thing makes completing-read keep the original order of the list passed to it.

#+begin_src emacs-lisp
(defun darius/zoxide-find-file ()
  "Find a file from your zoxide database"
  (interactive)
  (let* ((db (shell-command-to-string "zoxide query -l"))
         (entries (split-string db "\n" t))
         (table (lambda (string pred action)
                  (if (eq action 'metadata)
                      `(metadata (display-sort-function . identity))
                    (complete-with-action action entries string pred))))
         (selection (completing-read "Jump: " table nil t)))
    (find-file selection)))

(keymap-global-set "M-g z" #'darius/zoxide-find-file)
#+end_src

** Spawn terminal here
Spawn a terminal in the current directory.
This is hardcoded to foot because wayland is obviously superior.

#+begin_src emacs-lisp
(defun darius/spawn-terminal-here (arg)
  "Open an *eat* buffer in the current project if called without prefix.
If called with one C-u open a regular *eat* in the other window.
If called with two C-u's, spawn a terminal window (foot) in the current directory."
  (interactive "P")
  (cond
   ((null arg)
    (eat-project-other-window))
   ((equal arg '(4))
    (eat-other-window))
   ((equal arg '(16))
    (if-let* ((foot-path (executable-find "foot")))
        (call-process foot-path nil 0 nil "-D" (expand-file-name default-directory))))
   (t ; fallback
    (eat-other-window))))

(keymap-global-set "M-g t" #'darius/spawn-terminal-here)
#+end_src

** Maybe wrap with asterisk
Wrap the active region with a character, like '(' in electric-pair-mode

#+begin_src emacs-lisp
(defun darius/maybe-wrap-with-char (char)
  "If region is active, wrap it with CHAR, else insert CHAR.
   If called interactively, prompt for a character to use."
  (interactive "cChar: ")
  (when (use-region-p)
    (let ((beg (region-beginning))
          (end (region-end)))
      (goto-char end)
      (insert char)
      (goto-char beg)))
  (insert char))

(defun darius/maybe-wrap-org-setup (key)
  "Bind KEY in `org-mode-map' to maybe wrap."
  (define-key org-mode-map key
              (lambda () (interactive) (darius/maybe-wrap-with-char (string-to-char key)))))

;; wrap with * and ~ for `org-mode'
(with-eval-after-load 'org
  (add-hook 'org-mode-hook
            (lambda ()
              (darius/maybe-wrap-org-setup "*")
              (darius/maybe-wrap-org-setup "~"))))
#+end_src

** Swap semicolon and dash
In lisp-based modes and the minibuffer, I type ~-~ a lot more than ~;~
Most use-cases for semincolons are covered by ~comment-line~ and ~comment-dwim~

#+begin_src emacs-lisp
(defun darius/insert-dash-or-semicolon (arg)
  (interactive "P")
  (if (not arg)
      (insert "-")
    (insert ";")))

(define-minor-mode darius/dash-semicolon-minor-mode
  "When pressing the ; key, insert a - unless called with a prefix argument"
  :global nil
  :initial-value nil
  :lighter " :3"
  :keymap '((";" . darius/insert-dash-or-semicolon)))

(dolist (mode '(minibuffer-setup-hook
                emacs-lisp-mode-hook
                ielm-mode-hook
                org-mode-hook))
  (add-hook mode #'darius/dash-semicolon-minor-mode))
#+end_src

** Switch buffer or delete window
Use ~C-;~ to bring up a buffer prompt or delete the current window with prefix argument
With two prefixes call ~winner-undo~

#+begin_src emacs-lisp
(defun darius/switch-buffer-or-delete-window (arg)
  "Call `switch-to-buffer' or `delete-window'/`winnder-undo' if called with one/two C-u presses"
  (interactive "P")
  (cond
   ((null arg)
    (call-interactively #'switch-to-buffer))
   ((equal arg '(4))
    (delete-window))
   ((equal arg '(16))
    (winner-undo))
   (t ; fallback
    (call-interactively #'switch-to-buffer))))

(keymap-global-set "C-;" #'darius/switch-buffer-or-delete-window)
#+end_src

** COMMENT Todo comments
Prompt for a string and insert a command with that string.

~hl-todo~ seems to have something similar called ~hl-todo-occur~

#+begin_src emacs-lisp
(setq darius/comment-keyword-list
      '(("TODO") ("FIXME") ("NOTE") ("OPTIMIZE") ("HACK") ("BUG")))

(defun darius/todo-occur ()
  "List all lines containing a keyword from `darius/comment-keyword-list'"
  (interactive)
  (let ((keyword (completing-read "Occur keyword: " darius/comment-keyword-list)))
    (occur keyword)))
#+end_src
